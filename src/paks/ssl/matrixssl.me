/*
    matrixssl.me -- MatrixSSL Extension
 */

Me.load({ 
    targets: {
        matrixssl: {
            description: 'MatrixSSL SSL',
            config: function (target) {
                if (me.options.gen) {
                    return {
                        path: target.withpath || '/usr/src/matrixssl',
                        libpaths: [ '$(ME_EXT_MATRIXSSL_PATH)' ],
                        includes: [ '$(ME_EXT_MATRIXSSL_PATH)', '$(ME_EXT_MATRIXSSL_PATH)/matrixssl' ],
                        libraries: [(me.platform.os == 'windows') ? 'matrixssl.lib' : 'matrixssl'],
                    }
                }
                let path: Path? = target.withpath
                if (!path) {
                    if (me.dir.paks) {
                        path = me.dir.paks.join('matrixssl')
                    }
                    if (!path.exists) {
                        path = App.dir.join('../packages-' + me.platform.os + '-' + me.platform.arch, 'matrixssl/latest')
                    }
                }
                let search = [ (me.platform.os == 'windows') ? path.join('Release') : path ]
                let lib = probe('libmatrixssl.' + me.ext.shobj, {fullpath: true, search: search}).absolute
                let imports, libraries
                if (me.platform.os == 'windows') {
                    libraries = [ 'matrixssl.lib' ],
                    imports = [ lib, lib.replaceExt('lib') ]
                } else {
                    libraries = [ 'matrixssl' ]
                    imports = [ lib ]
                }
                let search = [ path.join('matrixssl') ]
                let incdir = probe('matrixsslApi.h', {search: search}).absolute
                return {
                    path:       path,
                    includes:   [ incdir, incdir.parent ]
                    libpaths:   [lib.parent],
                    libraries:  libraries,
                    imports:    imports,
                }
            },
            ifdef:     [ 'ssl' ],
            conflicts: [ 'est', 'nanossl', 'openssl' ],
        },
    },
})
